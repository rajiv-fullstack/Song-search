{"ast":null,"code":"var _cache = {};\nexport var cachedFetch = function cachedFetch(url, options) {\n  var cached = _cache[url];\n\n  if (cached !== undefined) {\n    try {\n      var response = new window.Response(new Blob([cached]));\n      return Promise.resolve(response);\n    } catch (err) {\n      // Old browsers. E.g. Firefox 38.\n      console.log(\"Unable to create new window.Response\", err);\n    }\n  }\n\n  return fetch(url, options).then(function (response) {\n    // let's only store in cache if the content-type is\n    // JSON or something non-binary\n    if (response.status === 200) {\n      var ct = response.headers.get(\"Content-Type\");\n\n      if (ct && (ct.match(/application\\/json/i) || ct.match(/text\\//i))) {\n        // There is a .json() instead of .text() but\n        // we're going to store it in _cache as\n        // string anyway.\n        // If we don't clone the response, it will be\n        // consumed by the time it's returned. This\n        // way we're being un-intrusive.\n        response.clone().text().then(function (content) {\n          _cache[url] = content;\n        });\n      }\n    }\n\n    return response;\n  });\n};","map":{"version":3,"sources":["/home/mandeep/Downloads/Song-sorch work/site/src/Cache.js"],"names":["_cache","cachedFetch","url","options","cached","undefined","response","window","Response","Blob","Promise","resolve","err","console","log","fetch","then","status","ct","headers","get","match","clone","text","content"],"mappings":"AAAA,IAAMA,MAAM,GAAG,EAAf;AAEA,OAAO,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAACC,GAAD,EAAMC,OAAN,EAAkB;AAC3C,MAAMC,MAAM,GAAGJ,MAAM,CAACE,GAAD,CAArB;;AACA,MAAIE,MAAM,KAAKC,SAAf,EAA0B;AACxB,QAAI;AACF,UAAMC,QAAQ,GAAG,IAAIC,MAAM,CAACC,QAAX,CAAoB,IAAIC,IAAJ,CAAS,CAACL,MAAD,CAAT,CAApB,CAAjB;AACA,aAAOM,OAAO,CAACC,OAAR,CAAgBL,QAAhB,CAAP;AACD,KAHD,CAGE,OAAOM,GAAP,EAAY;AACZ;AACAC,MAAAA,OAAO,CAACC,GAAR,CAAY,sCAAZ,EAAoDF,GAApD;AACD;AACF;;AAED,SAAOG,KAAK,CAACb,GAAD,EAAMC,OAAN,CAAL,CAAoBa,IAApB,CAAyB,UAAAV,QAAQ,EAAI;AAC1C;AACA;AACA,QAAIA,QAAQ,CAACW,MAAT,KAAoB,GAAxB,EAA6B;AAC3B,UAAMC,EAAE,GAAGZ,QAAQ,CAACa,OAAT,CAAiBC,GAAjB,CAAqB,cAArB,CAAX;;AACA,UAAIF,EAAE,KAAKA,EAAE,CAACG,KAAH,CAAS,oBAAT,KAAkCH,EAAE,CAACG,KAAH,CAAS,SAAT,CAAvC,CAAN,EAAmE;AACjE;AACA;AACA;AACA;AACA;AACA;AACAf,QAAAA,QAAQ,CACLgB,KADH,GAEGC,IAFH,GAGGP,IAHH,CAGQ,UAAAQ,OAAO,EAAI;AACfxB,UAAAA,MAAM,CAACE,GAAD,CAAN,GAAcsB,OAAd;AACD,SALH;AAMD;AACF;;AACD,WAAOlB,QAAP;AACD,GArBM,CAAP;AAsBD,CAlCM","sourcesContent":["const _cache = {};\n\nexport const cachedFetch = (url, options) => {\n  const cached = _cache[url];\n  if (cached !== undefined) {\n    try {\n      const response = new window.Response(new Blob([cached]));\n      return Promise.resolve(response);\n    } catch (err) {\n      // Old browsers. E.g. Firefox 38.\n      console.log(\"Unable to create new window.Response\", err);\n    }\n  }\n\n  return fetch(url, options).then(response => {\n    // let's only store in cache if the content-type is\n    // JSON or something non-binary\n    if (response.status === 200) {\n      const ct = response.headers.get(\"Content-Type\");\n      if (ct && (ct.match(/application\\/json/i) || ct.match(/text\\//i))) {\n        // There is a .json() instead of .text() but\n        // we're going to store it in _cache as\n        // string anyway.\n        // If we don't clone the response, it will be\n        // consumed by the time it's returned. This\n        // way we're being un-intrusive.\n        response\n          .clone()\n          .text()\n          .then(content => {\n            _cache[url] = content;\n          });\n      }\n    }\n    return response;\n  });\n};\n"]},"metadata":{},"sourceType":"module"}