{"ast":null,"code":"var _cache={};export var cachedFetch=function cachedFetch(url,options){var cached=_cache[url];if(cached!==undefined){try{var response=new window.Response(new Blob([cached]));return Promise.resolve(response);}catch(err){// Old browsers. E.g. Firefox 38.\nconsole.log(\"Unable to create new window.Response\",err);}}return fetch(url,options).then(function(response){// let's only store in cache if the content-type is\n// JSON or something non-binary\nif(response.status===200){var ct=response.headers.get(\"Content-Type\");if(ct&&(ct.match(/application\\/json/i)||ct.match(/text\\//i))){// There is a .json() instead of .text() but\n// we're going to store it in _cache as\n// string anyway.\n// If we don't clone the response, it will be\n// consumed by the time it's returned. This\n// way we're being un-intrusive.\nresponse.clone().text().then(function(content){_cache[url]=content;});}}return response;});};","map":{"version":3,"sources":["/home/mandeep/Downloads/Song-sorch work/site/src/Cache.js"],"names":["_cache","cachedFetch","url","options","cached","undefined","response","window","Response","Blob","Promise","resolve","err","console","log","fetch","then","status","ct","headers","get","match","clone","text","content"],"mappings":"AAAA,GAAMA,CAAAA,MAAM,CAAG,EAAf,CAEA,MAAO,IAAMC,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CAACC,GAAD,CAAMC,OAAN,CAAkB,CAC3C,GAAMC,CAAAA,MAAM,CAAGJ,MAAM,CAACE,GAAD,CAArB,CACA,GAAIE,MAAM,GAAKC,SAAf,CAA0B,CACxB,GAAI,CACF,GAAMC,CAAAA,QAAQ,CAAG,GAAIC,CAAAA,MAAM,CAACC,QAAX,CAAoB,GAAIC,CAAAA,IAAJ,CAAS,CAACL,MAAD,CAAT,CAApB,CAAjB,CACA,MAAOM,CAAAA,OAAO,CAACC,OAAR,CAAgBL,QAAhB,CAAP,CACD,CAAC,MAAOM,GAAP,CAAY,CACZ;AACAC,OAAO,CAACC,GAAR,CAAY,sCAAZ,CAAoDF,GAApD,EACD,CACF,CAED,MAAOG,CAAAA,KAAK,CAACb,GAAD,CAAMC,OAAN,CAAL,CAAoBa,IAApB,CAAyB,SAAAV,QAAQ,CAAI,CAC1C;AACA;AACA,GAAIA,QAAQ,CAACW,MAAT,GAAoB,GAAxB,CAA6B,CAC3B,GAAMC,CAAAA,EAAE,CAAGZ,QAAQ,CAACa,OAAT,CAAiBC,GAAjB,CAAqB,cAArB,CAAX,CACA,GAAIF,EAAE,GAAKA,EAAE,CAACG,KAAH,CAAS,oBAAT,GAAkCH,EAAE,CAACG,KAAH,CAAS,SAAT,CAAvC,CAAN,CAAmE,CACjE;AACA;AACA;AACA;AACA;AACA;AACAf,QAAQ,CACLgB,KADH,GAEGC,IAFH,GAGGP,IAHH,CAGQ,SAAAQ,OAAO,CAAI,CACfxB,MAAM,CAACE,GAAD,CAAN,CAAcsB,OAAd,CACD,CALH,EAMD,CACF,CACD,MAAOlB,CAAAA,QAAP,CACD,CArBM,CAAP,CAsBD,CAlCM","sourcesContent":["const _cache = {};\n\nexport const cachedFetch = (url, options) => {\n  const cached = _cache[url];\n  if (cached !== undefined) {\n    try {\n      const response = new window.Response(new Blob([cached]));\n      return Promise.resolve(response);\n    } catch (err) {\n      // Old browsers. E.g. Firefox 38.\n      console.log(\"Unable to create new window.Response\", err);\n    }\n  }\n\n  return fetch(url, options).then(response => {\n    // let's only store in cache if the content-type is\n    // JSON or something non-binary\n    if (response.status === 200) {\n      const ct = response.headers.get(\"Content-Type\");\n      if (ct && (ct.match(/application\\/json/i) || ct.match(/text\\//i))) {\n        // There is a .json() instead of .text() but\n        // we're going to store it in _cache as\n        // string anyway.\n        // If we don't clone the response, it will be\n        // consumed by the time it's returned. This\n        // way we're being un-intrusive.\n        response\n          .clone()\n          .text()\n          .then(content => {\n            _cache[url] = content;\n          });\n      }\n    }\n    return response;\n  });\n};\n"]},"metadata":{},"sourceType":"module"}